impl<N: SegmentId, T: OptFields> fmt::Display for GFA2<N, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f, 
            "{}{}{}{}{}{}{}",
            self.headers.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\n"),
            self.segments.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\n"),
            self.fragments.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\n"),
            self.edges.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\n"),
            self.gaps.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\n"),
            self.groups_o.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\n"),
            self.groups_u.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\n"),
        )
    }
}

impl<N: SegmentId, T: OptFields> fmt::Display for GroupU<N, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut opt = vec![];
        for tag in self.tag.fields(){
            opt.push(tag);
        }
        write!(
            f,
            "U\t{}\t{}\t{}",
            self.id.as_bstr(),
            // this inline method is useful but add a whitespace at the end of the var_field 
            // creating so an incorrect string 
            self.var_field.as_bstr().to_string() + " ",
            // this inline method is useful but add a tabspace at the end of the tag 
            // creating so an incorrect string 
            //self.tag.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\t"),
            opt.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\t"),
        )
    }
}

impl<N: SegmentId, T: OptFields> fmt::Display for GroupO<N, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut opt = vec![];
        for tag in self.tag.fields(){
            opt.push(tag);
        }
        write!(
            f,
            "O\t{}\t{}\t{}",
            self.id.as_bstr(),
            // this inline method is useful but add a whitespace at the end of the var_field 
            // creating so an incorrect string 
            self.var_field.as_bstr().to_string() + " ",
            opt.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\t"),
        )
    }
}

impl<N: SegmentId, T: OptFields> fmt::Display for Gap<N, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut opt = vec![];
        for tag in self.tag.fields(){
            opt.push(tag);
        }
        write!(
            f,
            "G\t{}\t{}\t{}\t{}\t{}\t{}",
            self.id,
            self.sid1.as_bstr(),
            self.sid2.as_bstr(),
            self.dist.as_bstr(),
            self.var.as_bstr(),
            opt.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\t"),
        )
    }
}

impl<N: SegmentId, T: OptFields> fmt::Display for Edge<N, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut opt = vec![];
        for tag in self.tag.fields(){
            opt.push(tag);
        }
        write!(
            f,
            "E\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}",
            self.id,
            self.sid1.as_bstr(),
            self.sid2.as_bstr(),
            self.beg1.as_bstr(),
            self.end1.as_bstr(),
            self.beg2.as_bstr(),
            self.end2.as_bstr(),
            self.alignment.as_bstr(),
            opt.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\t"),
        )
    }
}

impl<N: SegmentId, T: OptFields> fmt::Display for Fragment<N, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut opt = vec![];
        for tag in self.tag.fields(){
            opt.push(tag);
        }
        write!(
            f,
            "F\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}",
            self.id,
            self.ext_ref.as_bstr(),
            self.sbeg.as_bstr(),
            self.send.as_bstr(),
            self.fbeg.as_bstr(),
            self.fend.as_bstr(),
            self.alignment.as_bstr(),
            opt.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\t"),
        )
    }
}

impl<N: SegmentId, T: OptFields> fmt::Display for Segment<N, T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut opt = vec![];
        for tag in self.tag.fields(){
            opt.push(tag);
        }
        write!(
            f,
            "S\t{}\t{}\t{}\t{}",
            self.id,
            self.len.as_bstr(),
            self.sequence.as_bstr(),
            opt.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\t"),
        )
    }
}

impl<T: OptFields> fmt::Display for Header<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut opt = vec![];
        for tag in self.tag.fields(){
            opt.push(tag);
        }
        write!(
            f,
            "H\tVN:{}\t{}",
            self.version.unwrap().as_bstr(),
            opt.iter().fold(String::new(), |acc, str| acc + &str.to_string() + "\t"),
        )
    }  
}